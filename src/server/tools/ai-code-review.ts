import { McpServer } from "@modelcontextprotocol/sdk/server/mcp.js";
import { z } from "zod";
import { GitLabClient } from "../../gitlab/client";
import type { 
  AICodeReviewResult, 
  CodeReviewIssue, 
  CodeReviewRules, 
  FileFilterConfig,
  CodeReviewReport,
  GitLabFileChange 
} from "../../config/types";

/**
 * ‰ª£Á†ÅÂÆ°Êü•ËßÑÂàôÈÖçÁΩÆ
 */
const CODE_REVIEW_RULES: Record<string, CodeReviewRules> = {
  '.ts': {
    focus_areas: ['Á±ªÂûãÂÆâÂÖ®', 'ÊÄßËÉΩ‰ºòÂåñ', '‰ª£Á†ÅËßÑËåÉ', 'ÈîôËØØÂ§ÑÁêÜ'],
    specific_rules: [
      'Á°Æ‰øùÊâÄÊúâÂáΩÊï∞ÈÉΩÊúâÊòéÁ°ÆÁöÑËøîÂõûÁ±ªÂûã',
      'ÈÅøÂÖç‰ΩøÁî® any Á±ªÂûãÔºå‰ΩøÁî®ÂÖ∑‰ΩìÁ±ªÂûãÊàñÊ≥õÂûã',
      'ÂºÇÊ≠•ÂáΩÊï∞ÂøÖÈ°ªÊ≠£Á°ÆÂ§ÑÁêÜÈîôËØØ',
      'ÁªÑ‰ª∂ÂíåÂáΩÊï∞Âêç‰ΩøÁî® PascalCase Êàñ camelCase',
      'ÈÅøÂÖçÂú®Âæ™ÁéØ‰∏≠ËøõË°åÂºÇÊ≠•Êìç‰Ωú',
      '‰ΩøÁî® const assertions Êù•Ëé∑ÂæóÊõ¥Á≤æÁ°ÆÁöÑÁ±ªÂûãÊé®Êñ≠'
    ],
    ignore_patterns: ['*.d.ts', '*.test.ts', '*.spec.ts'],
    severity_mapping: {
      'anyÁ±ªÂûã‰ΩøÁî®': 'warning',
      'Êú™Â§ÑÁêÜÁöÑPromise': 'critical',
      'Âæ™ÁéØ‰∏≠ÁöÑÂºÇÊ≠•Êìç‰Ωú': 'warning',
      'Áº∫Â∞ëÁ±ªÂûãÊ≥®Ëß£': 'suggestion'
    }
  },
  '.vue': {
    focus_areas: ['ÁªÑ‰ª∂ËÆæËÆ°', 'ÊÄßËÉΩ‰ºòÂåñ', 'VueÊúÄ‰Ω≥ÂÆûË∑µ', 'ÂèØËÆøÈóÆÊÄß'],
    specific_rules: [
      'template ‰∏≠ÈÅøÂÖçÂ§çÊùÇÁöÑË°®ËææÂºè',
      'ÂêàÁêÜ‰ΩøÁî® computed Âíå watch',
      'Á°Æ‰øùÁªÑ‰ª∂ÁöÑ props ÊúâÊ≠£Á°ÆÁöÑÁ±ªÂûãÂÆö‰πâ',
      'emit ‰∫ã‰ª∂ÈúÄË¶ÅÊòéÁ°ÆÂÆö‰πâÁ±ªÂûã',
      'ÈÅøÂÖçÂú® template ‰∏≠Áõ¥Êé•‰øÆÊîπ props',
      '‰ΩøÁî®Ê≠£Á°ÆÁöÑÁîüÂëΩÂë®ÊúüÈí©Â≠ê'
    ],
    ignore_patterns: [],
    severity_mapping: {
      'templateË°®ËææÂºèËøá‰∫éÂ§çÊùÇ': 'warning',
      'propsÁº∫Â∞ëÁ±ªÂûã': 'warning',
      'Áõ¥Êé•‰øÆÊîπprops': 'critical'
    }
  },
  '.js': {
    focus_areas: ['ES6+ËØ≠Ê≥ï', 'ÊÄßËÉΩ', 'ÈîôËØØÂ§ÑÁêÜ', '‰ª£Á†ÅËßÑËåÉ'],
    specific_rules: [
      '‰ΩøÁî® const/let Êõø‰ª£ var',
      '‰ΩøÁî®ÁÆ≠Â§¥ÂáΩÊï∞Êàñ function Â£∞Êòé',
      'ÈÅøÂÖçÂõûË∞ÉÂú∞Áã±Ôºå‰ΩøÁî® Promise Êàñ async/await',
      'Ê≠£Á°ÆÂ§ÑÁêÜÂºÇÂ∏∏ÂíåÈîôËØØ',
      '‰ΩøÁî®‰∏•Ê†ºÊ®°Âºè',
      'ÈÅøÂÖçÂÖ®Â±ÄÂèòÈáèÊ±°Êüì'
    ],
    ignore_patterns: ['*.min.js', '*.bundle.js'],
    severity_mapping: {
      '‰ΩøÁî®varÂ£∞Êòé': 'suggestion',
      'ÂõûË∞ÉÂú∞Áã±': 'warning',
      'Êú™Â§ÑÁêÜÂºÇÂ∏∏': 'critical'
    }
  }
};

/**
 * Êñá‰ª∂ËøáÊª§ÈÖçÁΩÆ
 */
const FILE_FILTER_CONFIG: FileFilterConfig = {
  includedExtensions: ['.ts', '.tsx', '.js', '.jsx', '.vue', '.py', '.java', '.cs', '.go', '.rs'],
  excludePatterns: [
    /node_modules/,
    /dist/,
    /build/,
    /\.git/,
    /coverage/,
    /\.nyc_output/,
    /\.next/,
    /\.nuxt/,
    /\.vuepress/,
    /\.temp/,
    /\.cache/,
    /\.DS_Store/,
    /\.env/,
    /\.log$/,
    /\.lock$/,
    /package-lock\.json$/,
    /yarn\.lock$/,
    /pnpm-lock\.yaml$/,
    /\.map$/,
    /\.min\./,
    /\.d\.ts$/,
    /\.test\./,
    /\.spec\./,
    /\.stories\./,
    /\.config\./,
    /\.md$/,
    /README/i,
    /CHANGELOG/i,
    /LICENSE/i
  ],
  maxFileSize: 100 * 1024, // 100KB
  maxDiffLines: 500
};

/**
 * Ê≥®ÂÜåAI‰ª£Á†ÅÂÆ°Êü•Áõ∏ÂÖ≥ÁöÑÂ∑•ÂÖ∑
 */
export function registerAICodeReviewTools(server: McpServer, gitlabClient: GitLabClient): void {
  
  // Ëé∑ÂèñÊñá‰ª∂ÁâπÂÆöÁöÑ‰ª£Á†ÅÂÆ°Êü•ËßÑÂàô
  server.tool(
    "get_file_code_review_rules",
    {
      title: "Ëé∑ÂèñÊñá‰ª∂‰ª£Á†ÅÂÆ°Êü•ËßÑÂàô",
      description: "Ê†πÊçÆÊñá‰ª∂Á±ªÂûãÂíåË∑ØÂæÑËé∑ÂèñÁõ∏Â∫îÁöÑ‰ª£Á†ÅÂÆ°Êü•ËßÑÂàô",
      inputSchema: {
        filePath: z.string().describe("Êñá‰ª∂Ë∑ØÂæÑ"),
        fileExtension: z.string().optional().describe("Êñá‰ª∂Êâ©Â±ïÂêç")
      }
    },
    async ({ filePath, fileExtension }) => {
      try {
        const ext = fileExtension || getFileExtension(filePath);
        const rules = getCodeReviewRules(ext, filePath);
        const shouldReview = shouldReviewFile(filePath, ext);
        
        return {
          content: [
            {
              type: "text",
              text: JSON.stringify({
                file_path: filePath,
                extension: ext,
                rules,
                should_review: shouldReview,
                message: shouldReview ? "Êñá‰ª∂ÈúÄË¶ÅÂÆ°Êü•" : "Êñá‰ª∂Â∑≤Ë¢´ËøáÊª§Ôºå‰∏çÈúÄË¶ÅÂÆ°Êü•"
              }, null, 2)
            }
          ]
        };
      } catch (error) {
        throw new Error(`Ëé∑Âèñ‰ª£Á†ÅÂÆ°Êü•ËßÑÂàôÂ§±Ë¥•: ${error instanceof Error ? error.message : String(error)}`);
      }
    }
  );

  // AI‰ª£Á†ÅÂÆ°Êü•‰∏ªÂ∑•ÂÖ∑
  server.tool(
    "ai_code_review",
    {
      title: "AI‰ª£Á†ÅÂÆ°Êü•",
      description: "ÂØπÊåáÂÆöÁöÑÂêàÂπ∂ËØ∑Ê±ÇËøõË°åÊô∫ËÉΩ‰ª£Á†ÅÂÆ°Êü•ÔºåÂü∫‰∫éÊúÄ‰Ω≥ÂÆûË∑µÂíåËßÑÂàôÂºïÊìé",
      inputSchema: {
        projectPath: z.string().describe("È°πÁõÆË∑ØÂæÑÔºåÊ†ºÂºè: owner/repo"),
        mergeRequestIid: z.number().describe("ÂêàÂπ∂ËØ∑Ê±ÇÁöÑÂÜÖÈÉ®ID"),
        autoComment: z.boolean().optional().default(false).describe("ÊòØÂê¶Ëá™Âä®Ê∑ªÂä†ÂÆ°Êü•ËØÑËÆ∫Âà∞MR"),
        reviewDepth: z.enum(["quick", "standard", "thorough"]).optional().default("standard").describe("ÂÆ°Êü•Ê∑±Â∫¶"),
        focusFiles: z.array(z.string()).optional().describe("ÈáçÁÇπÂÆ°Êü•ÁöÑÊñá‰ª∂ÂàóË°®ÔºåÁïôÁ©∫ÂàôÂÆ°Êü•ÊâÄÊúâÁõ∏ÂÖ≥Êñá‰ª∂"),
        commentStyle: z.enum(["detailed", "summary", "minimal"]).optional().default("detailed").describe("ËØÑËÆ∫È£éÊ†º")
      }
    },
    async ({ projectPath, mergeRequestIid, autoComment = false, reviewDepth = "standard", focusFiles, commentStyle = "detailed" }) => {
      try {
        console.log(`üîç ÂºÄÂßãAI‰ª£Á†ÅÂÆ°Êü•: ${projectPath}#${mergeRequestIid}`);
        
        // 1. Ëé∑ÂèñMRÂü∫Êú¨‰ø°ÊÅØÂíåÂèòÊõ¥
        const project = await gitlabClient.getProject(projectPath);
        const mr = await gitlabClient.getMergeRequest(project.id, mergeRequestIid);
        const changes = await gitlabClient.getMergeRequestChanges(project.id, mergeRequestIid);
        
        console.log(`üìã MR‰ø°ÊÅØ: ${mr.title} by ${mr.author.username}`);
        console.log(`üìÅ ÊÄªÊñá‰ª∂ÂèòÊõ¥: ${changes.changes.length}‰∏™`);
        
        // 2. ËøáÊª§ÂíåÈ¢ÑÂ§ÑÁêÜÊñá‰ª∂
        const filteredChanges = filterReviewableChanges(changes.changes, focusFiles);
        console.log(`üìã ËøáÊª§ÂêéÈúÄË¶ÅÂÆ°Êü•ÁöÑÊñá‰ª∂: ${filteredChanges.length}‰∏™`);
        
        if (filteredChanges.length === 0) {
          return {
            content: [
              {
                type: "text",
                text: JSON.stringify({
                  message: "Ê≤°ÊúâÊâæÂà∞ÈúÄË¶ÅÂÆ°Êü•ÁöÑÊñá‰ª∂",
                  total_changes: changes.changes.length,
                  filtered_files: filteredChanges.map(c => c.new_path),
                  skipped_reason: "ÊâÄÊúâÊñá‰ª∂ÈÉΩË¢´ËøáÊª§ËßÑÂàôÊéíÈô§Êàñ‰∏çÂú®ÊîØÊåÅÁöÑÊñá‰ª∂Á±ªÂûãËåÉÂõ¥ÂÜÖ"
                }, null, 2)
              }
            ]
          };
        }
        
        // 3. ËøõË°åAIÂÆ°Êü•
        const reviewResults = await performBatchAIReview(filteredChanges, reviewDepth);
        
        // 4. ÁîüÊàêÂÆ°Êü•Êä•Âëä
        const reviewReport = generateReviewReport(reviewResults, mr);
        
        // 5. Â¶ÇÊûúÂêØÁî®Ëá™Âä®ËØÑËÆ∫ÔºåÊé®ÈÄÅÂà∞GitLab
        let commentResult = null;
        if (autoComment && reviewResults.length > 0) {
          commentResult = await pushReviewCommentsToGitLab(
            gitlabClient, 
            project.id, 
            mergeRequestIid, 
            reviewResults, 
            reviewReport,
            commentStyle
          );
        }
        
        return {
          content: [
            {
              type: "text",
              text: JSON.stringify({
                merge_request: {
                  title: mr.title,
                  author: mr.author.username,
                  source_branch: mr.source_branch,
                  target_branch: mr.target_branch,
                  web_url: mr.web_url
                },
                review_summary: reviewReport,
                detailed_results: reviewResults,
                auto_commented: autoComment,
                comment_result: commentResult,
                reviewed_at: new Date().toISOString(),
                review_settings: {
                  depth: reviewDepth,
                  focus_files: focusFiles,
                  comment_style: commentStyle
                }
              }, null, 2)
            }
          ]
        };
        
      } catch (error) {
        console.error('‚ùå AI‰ª£Á†ÅÂÆ°Êü•Â§±Ë¥•:', error);
        throw new Error(`AI‰ª£Á†ÅÂÆ°Êü•Â§±Ë¥•: ${error instanceof Error ? error.message : String(error)}`);
      }
    }
  );
  
  // ÊâãÂä®Êé®ÈÄÅÂÆ°Êü•ËØÑËÆ∫
  server.tool(
    "push_review_comments",
    {
      title: "Êé®ÈÄÅÂÆ°Êü•ËØÑËÆ∫",
      description: "Â∞Ü‰ª£Á†ÅÂÆ°Êü•ÁªìÊûúÊâãÂä®Êé®ÈÄÅÂà∞GitLab MRËØÑËÆ∫",
      inputSchema: {
        projectPath: z.string().describe("È°πÁõÆË∑ØÂæÑÔºåÊ†ºÂºè: owner/repo"),
        mergeRequestIid: z.number().describe("ÂêàÂπ∂ËØ∑Ê±ÇÁöÑÂÜÖÈÉ®ID"),
        reviewResults: z.string().describe("ÂÆ°Êü•ÁªìÊûúJSONÂ≠óÁ¨¶‰∏≤"),
        reviewReport: z.string().optional().describe("ÂÆ°Êü•Êä•ÂëäJSONÂ≠óÁ¨¶‰∏≤"),
        commentStyle: z.enum(["detailed", "summary", "minimal"]).optional().default("detailed").describe("ËØÑËÆ∫È£éÊ†º")
      }
    },
    async ({ projectPath, mergeRequestIid, reviewResults, reviewReport, commentStyle = "detailed" }) => {
      try {
        const project = await gitlabClient.getProject(projectPath);
        
        // Ëß£ÊûêJSONÂ≠óÁ¨¶‰∏≤
        const parsedResults: AICodeReviewResult[] = JSON.parse(reviewResults);
        const parsedReport = reviewReport ? JSON.parse(reviewReport) : null;
        
        const pushResult = await pushReviewCommentsToGitLab(
          gitlabClient, 
          project.id, 
          mergeRequestIid, 
          parsedResults, 
          parsedReport,
          commentStyle
        );
        
        return {
          content: [
            {
              type: "text",
              text: JSON.stringify(pushResult, null, 2)
            }
          ]
        };
      } catch (error) {
        throw new Error(`Êé®ÈÄÅËØÑËÆ∫Â§±Ë¥•: ${error instanceof Error ? error.message : String(error)}`);
      }
    }
  );

  // ÊâπÈáèÊñá‰ª∂ËøáÊª§Â∑•ÂÖ∑
  server.tool(
    "filter_reviewable_files",
    {
      title: "ËøáÊª§ÂèØÂÆ°Êü•Êñá‰ª∂",
      description: "Ê†πÊçÆÈÖçÁΩÆËßÑÂàôËøáÊª§Âá∫ÈúÄË¶Å‰ª£Á†ÅÂÆ°Êü•ÁöÑÊñá‰ª∂",
      inputSchema: {
        projectPath: z.string().describe("È°πÁõÆË∑ØÂæÑÔºåÊ†ºÂºè: owner/repo"),
        mergeRequestIid: z.number().describe("ÂêàÂπ∂ËØ∑Ê±ÇÁöÑÂÜÖÈÉ®ID"),
        focusFiles: z.array(z.string()).optional().describe("ÈáçÁÇπÂÖ≥Ê≥®ÁöÑÊñá‰ª∂ÂàóË°®")
      }
    },
    async ({ projectPath, mergeRequestIid, focusFiles }) => {
      try {
        const project = await gitlabClient.getProject(projectPath);
        const changes = await gitlabClient.getMergeRequestChanges(project.id, mergeRequestIid);
        
        const filteredChanges = filterReviewableChanges(changes.changes, focusFiles);
        
        return {
          content: [
            {
              type: "text",
              text: JSON.stringify({
                total_files: changes.changes.length,
                reviewable_files: filteredChanges.length,
                filtered_files: filteredChanges.map(change => ({
                  path: change.new_path,
                  extension: getFileExtension(change.new_path),
                  change_type: change.new_file ? 'new' : change.deleted_file ? 'deleted' : 'modified',
                  diff_lines: change.diff ? change.diff.split('\n').length : 0
                })),
                excluded_files: changes.changes
                  .filter(change => !filteredChanges.includes(change))
                  .map(change => ({
                    path: change.new_path,
                    reason: getExclusionReason(change)
                  }))
              }, null, 2)
            }
          ]
        };
      } catch (error) {
        throw new Error(`Êñá‰ª∂ËøáÊª§Â§±Ë¥•: ${error instanceof Error ? error.message : String(error)}`);
      }
    }
  );
}

/**
 * Ëé∑ÂèñÊñá‰ª∂Êâ©Â±ïÂêç
 */
function getFileExtension(filePath: string): string {
  const match = filePath.match(/\.([^.]+)$/);
  return match ? `.${match[1]}` : '';
}

/**
 * Ëé∑ÂèñÊñá‰ª∂ÁöÑ‰ª£Á†ÅÂÆ°Êü•ËßÑÂàô
 */
function getCodeReviewRules(extension: string, filePath: string): CodeReviewRules {
  const rules = CODE_REVIEW_RULES[extension];
  if (!rules) {
    return {
      focus_areas: ['Âü∫Á°Ä‰ª£Á†ÅË¥®Èáè', 'ÂèØËØªÊÄß', 'Áª¥Êä§ÊÄß'],
      specific_rules: [
        'Á°Æ‰øù‰ª£Á†ÅÈÄªËæëÊ∏ÖÊô∞',
        'ÈÅøÂÖçËøáÂ∫¶Â§çÊùÇÁöÑÂµåÂ•ó',
        'ÂáΩÊï∞ÂíåÂèòÈáèÂëΩÂêçË¶ÅÊúâÊÑè‰πâ',
        'Ê∑ªÂä†ÂøÖË¶ÅÁöÑÊ≥®Èáä'
      ],
      ignore_patterns: [],
      severity_mapping: {}
    };
  }
  
  return rules;
}

/**
 * Âà§Êñ≠Êñá‰ª∂ÊòØÂê¶ÈúÄË¶ÅÂÆ°Êü•
 */
function shouldReviewFile(filePath: string, extension: string): boolean {
  // Ê£ÄÊü•Êâ©Â±ïÂêç
  if (!FILE_FILTER_CONFIG.includedExtensions.includes(extension)) {
    return false;
  }
  
  // Ê£ÄÊü•ÊéíÈô§Ê®°Âºè
  for (const pattern of FILE_FILTER_CONFIG.excludePatterns) {
    if (pattern.test(filePath)) {
      return false;
    }
  }
  
  return true;
}

/**
 * ËøáÊª§ÂèØÂÆ°Êü•ÁöÑÂèòÊõ¥
 */
function filterReviewableChanges(changes: GitLabFileChange[], focusFiles?: string[]): GitLabFileChange[] {
  return changes.filter(change => {
    // Â¶ÇÊûúÊåáÂÆö‰∫ÜÈáçÁÇπÊñá‰ª∂ÔºåÂè™ÂÆ°Êü•ÊåáÂÆöÊñá‰ª∂
    if (focusFiles && focusFiles.length > 0) {
      return focusFiles.some(file => change.new_path.includes(file));
    }
    
    // ÊéíÈô§Âà†Èô§ÁöÑÊñá‰ª∂
    if (change.deleted_file) {
      return false;
    }
    
    // Ê£ÄÊü•Êñá‰ª∂ÊòØÂê¶Â∫îËØ•Ë¢´ÂÆ°Êü•
    const extension = getFileExtension(change.new_path);
    if (!shouldReviewFile(change.new_path, extension)) {
      return false;
    }
    
    // Ê£ÄÊü•diffÂ§ßÂ∞è
    if (change.diff && change.diff.split('\n').length > FILE_FILTER_CONFIG.maxDiffLines) {
      console.log(`‚ö†Ô∏è  Êñá‰ª∂ ${change.new_path} diffËøáÂ§ßÔºåË∑≥ËøáÂÆ°Êü•`);
      return false;
    }
    
    return true;
  });
}

/**
 * Ëé∑ÂèñÊñá‰ª∂Ë¢´ÊéíÈô§ÁöÑÂéüÂõ†
 */
function getExclusionReason(change: GitLabFileChange): string {
  if (change.deleted_file) {
    return 'Êñá‰ª∂Â∑≤Âà†Èô§';
  }
  
  const extension = getFileExtension(change.new_path);
  if (!FILE_FILTER_CONFIG.includedExtensions.includes(extension)) {
    return 'Êñá‰ª∂Á±ªÂûã‰∏çÊîØÊåÅ';
  }
  
  for (const pattern of FILE_FILTER_CONFIG.excludePatterns) {
    if (pattern.test(change.new_path)) {
      return 'ÂåπÈÖçÊéíÈô§Ê®°Âºè';
    }
  }
  
  if (change.diff && change.diff.split('\n').length > FILE_FILTER_CONFIG.maxDiffLines) {
    return 'diffËøáÂ§ß';
  }
  
  return 'Êú™Áü•ÂéüÂõ†';
}

/**
 * ÊâπÈáèËøõË°åAIÂÆ°Êü• (Ê®°ÊãüÂÆûÁé∞)
 */
async function performBatchAIReview(
  changes: GitLabFileChange[], 
  reviewDepth: string
): Promise<AICodeReviewResult[]> {
  const results: AICodeReviewResult[] = [];
  
  console.log(`ü§ñ ÂºÄÂßãËøõË°åÊâπÈáèAIÂÆ°Êü•ÔºåÊ∑±Â∫¶: ${reviewDepth}...`);
  
  for (const change of changes) {
    try {
      const extension = getFileExtension(change.new_path);
      const rules = getCodeReviewRules(extension, change.new_path);
      
      // ËøôÈáåÂ∫îËØ•Ë∞ÉÁî®ÂÆûÈôÖÁöÑLLM APIÔºåÁõÆÂâç‰ΩøÁî®Ê®°ÊãüÂÆûÁé∞
      const result = await simulateAIReview(change, rules, reviewDepth);
      
      results.push({
        file_path: change.new_path,
        overall_score: result.overall_score,
        issues: result.issues,
        suggestions: result.suggestions,
        compliance_status: result.compliance_status
      });
      
      console.log(`‚úÖ ÂÆ°Êü•ÂÆåÊàê: ${change.new_path} (ËØÑÂàÜ: ${result.overall_score})`);
      
    } catch (error) {
      console.error(`‚ùå ÂÆ°Êü•Êñá‰ª∂ ${change.new_path} Â§±Ë¥•:`, error);
      // ÁªßÁª≠Â§ÑÁêÜÂÖ∂‰ªñÊñá‰ª∂
    }
  }
  
  return results;
}

/**
 * Ê®°ÊãüAIÂÆ°Êü• (Âú®ÂÆûÈôÖ‰ΩøÁî®‰∏≠Â∫îËØ•ÊõøÊç¢‰∏∫ÁúüÂÆûÁöÑLLMË∞ÉÁî®)
 */
async function simulateAIReview(
  change: GitLabFileChange, 
  rules: CodeReviewRules,
  reviewDepth: string
): Promise<{
  overall_score: number;
  issues: CodeReviewIssue[];
  suggestions: string[];
  compliance_status: 'PASS' | 'WARNING' | 'CRITICAL';
}> {
  // Ê®°ÊãüÂ§ÑÁêÜÂª∂Ëøü
  await new Promise(resolve => setTimeout(resolve, 500));
  
  const mockIssues: CodeReviewIssue[] = [];
  const mockSuggestions: string[] = [];
  
  // Ê†πÊçÆÊñá‰ª∂Á±ªÂûãÂíåÂÜÖÂÆπÁîüÊàêÊ®°ÊãüÈóÆÈ¢ò
  const extension = getFileExtension(change.new_path);
  
  if (extension === '.ts' || extension === '.js') {
    if (change.diff?.includes('console.log')) {
      mockIssues.push({
        line_number: Math.floor(Math.random() * 50) + 1,
        severity: 'warning',
        category: '‰ª£Á†ÅË¥®Èáè',
        title: 'ÂåÖÂê´Ë∞ÉËØïËØ≠Âè•',
        description: '‰ª£Á†Å‰∏≠ÂåÖÂê´console.logË∞ÉËØïËØ≠Âè•',
        suggestion: 'ÁßªÈô§console.logËØ≠Âè•Êàñ‰ΩøÁî®Ê≠£ÂºèÁöÑÊó•ÂøóÊ°ÜÊû∂',
        auto_fixable: true,
        rule_source: '‰ª£Á†ÅÊ∏ÖÁêÜÊúÄ‰Ω≥ÂÆûË∑µ'
      });
    }
    
    if (change.diff?.includes('any')) {
      mockIssues.push({
        line_number: Math.floor(Math.random() * 50) + 1,
        severity: 'warning',
        category: 'Á±ªÂûãÂÆâÂÖ®',
        title: '‰ΩøÁî®‰∫ÜanyÁ±ªÂûã',
        description: '‰ΩøÁî®anyÁ±ªÂûã‰ºöÂ§±ÂéªTypeScriptÁöÑÁ±ªÂûãÊ£ÄÊü•‰ºòÂäø',
        suggestion: '‰ΩøÁî®ÂÖ∑‰ΩìÁöÑÁ±ªÂûãÂÆö‰πâÊàñÊ≥õÂûãÊù•Êõø‰ª£any',
        auto_fixable: false,
        rule_source: 'TypeScriptÊúÄ‰Ω≥ÂÆûË∑µ'
      });
    }
  }
  
  if (extension === '.vue') {
    mockSuggestions.push('Âª∫ËÆÆ‰ΩøÁî®Composition APIÊù•ÊèêÈ´ò‰ª£Á†ÅÂ§çÁî®ÊÄß');
    mockSuggestions.push('ËÄÉËôë‰∏∫ÁªÑ‰ª∂Ê∑ªÂä†ÂøÖË¶ÅÁöÑpropÈ™åËØÅ');
  }
  
  // Ê†πÊçÆÂÆ°Êü•Ê∑±Â∫¶Ë∞ÉÊï¥ÈóÆÈ¢òÊï∞Èáè
  const issueMultiplier = reviewDepth === 'quick' ? 0.5 : reviewDepth === 'thorough' ? 1.5 : 1;
  const finalIssueCount = Math.max(1, Math.floor(mockIssues.length * issueMultiplier));
  
  if (mockIssues.length === 0) {
    mockSuggestions.push('‰ª£Á†ÅË¥®ÈáèËâØÂ•ΩÔºåÂª∫ËÆÆÁªßÁª≠‰øùÊåÅ');
    mockSuggestions.push('ËÄÉËôëÊ∑ªÂä†Êõ¥Â§öÁöÑÂçïÂÖÉÊµãËØïË¶ÜÁõñ');
  }
  
  const criticalCount = mockIssues.filter(i => i.severity === 'critical').length;
  const warningCount = mockIssues.filter(i => i.severity === 'warning').length;
  
  const overall_score = Math.max(60, 100 - (criticalCount * 20) - (warningCount * 10) - (mockIssues.length * 2));
  const compliance_status = criticalCount > 0 ? 'CRITICAL' : warningCount > 0 ? 'WARNING' : 'PASS';
  
  return {
    overall_score,
    issues: mockIssues.slice(0, finalIssueCount),
    suggestions: mockSuggestions,
    compliance_status
  };
}

/**
 * ÁîüÊàêÂÆ°Êü•Êä•Âëä
 */
function generateReviewReport(results: AICodeReviewResult[], mr: any): CodeReviewReport {
  const totalIssues = results.reduce((sum, result) => sum + result.issues.length, 0);
  const criticalIssues = results.reduce((sum, result) => 
    sum + result.issues.filter(issue => issue.severity === 'critical').length, 0);
  const warnings = results.reduce((sum, result) => 
    sum + result.issues.filter(issue => issue.severity === 'warning').length, 0);
  const suggestions = results.reduce((sum, result) => 
    sum + result.issues.filter(issue => issue.severity === 'suggestion').length, 0);
  
  const averageScore = results.length > 0 
    ? Math.round(results.reduce((sum, result) => sum + result.overall_score, 0) / results.length)
    : 0;
  
  const overallStatus = criticalIssues > 0 ? 'CRITICAL' : 
                       warnings > 0 ? 'WARNING' : 'PASS';
  
  const recommendations = generateOverallRecommendations(results, mr);
  
  return {
    summary: {
      files_reviewed: results.length,
      total_issues: totalIssues,
      critical_issues: criticalIssues,
      warnings: warnings,
      suggestions: suggestions,
      average_score: averageScore,
      overall_status: overallStatus
    },
    recommendations,
    review_metadata: {
      reviewed_by: 'AI Code Reviewer',
      review_time: new Date().toISOString(),
      mr_info: {
        title: mr.title,
        author: mr.author.username,
        changes_count: results.length
      }
    }
  };
}

/**
 * ÁîüÊàêÊÄª‰ΩìÂª∫ËÆÆ
 */
function generateOverallRecommendations(results: AICodeReviewResult[], mr: any): string[] {
  const recommendations: string[] = [];
  
  const criticalCount = results.reduce((sum, r) => 
    sum + r.issues.filter(i => i.severity === 'critical').length, 0);
  const warningCount = results.reduce((sum, r) => 
    sum + r.issues.filter(i => i.severity === 'warning').length, 0);
  
  if (criticalCount > 0) {
    recommendations.push(`üö® ÂèëÁé∞ ${criticalCount} ‰∏™‰∏•ÈáçÈóÆÈ¢òÔºåÂº∫ÁÉàÂª∫ËÆÆÂú®ÂêàÂπ∂Ââç‰øÆÂ§ç`);
  }
  
  if (warningCount > 3) {
    recommendations.push(`‚ö†Ô∏è  ÂèëÁé∞ËæÉÂ§öË≠¶ÂëäÈóÆÈ¢ò (${warningCount}‰∏™)ÔºåÂª∫ËÆÆ‰ºòÂÖàÂ§ÑÁêÜ`);
  }
  
  if (results.length > 15) {
    recommendations.push('üìä Ê≠§MRÊ∂âÂèäÊñá‰ª∂ËæÉÂ§öÔºåÂª∫ËÆÆËÄÉËôëÊãÜÂàÜ‰∏∫Êõ¥Â∞èÁöÑMR‰æø‰∫éÂÆ°Êü•ÂíåÊµãËØï');
  }
  
  const lowScoreFiles = results.filter(r => r.overall_score < 70);
  if (lowScoreFiles.length > 0) {
    recommendations.push(`üìâ ${lowScoreFiles.length} ‰∏™Êñá‰ª∂Ë¥®ÈáèËØÑÂàÜËæÉ‰Ωé(<70ÂàÜ)ÔºåÈúÄË¶ÅÈáçÁÇπÂÖ≥Ê≥®`);
  }
  
  // Âü∫‰∫éÊñá‰ª∂Á±ªÂûãÁöÑÂª∫ËÆÆ
  const hasTestFiles = results.some(r => r.file_path.includes('.test.') || r.file_path.includes('.spec.'));
  const hasSourceFiles = results.some(r => !r.file_path.includes('.test.') && !r.file_path.includes('.spec.'));
  
  if (hasSourceFiles && !hasTestFiles) {
    recommendations.push('üß™ Âª∫ËÆÆ‰∏∫Êñ∞ÂäüËÉΩÊ∑ªÂä†Áõ∏Â∫îÁöÑÂçïÂÖÉÊµãËØï');
  }
  
  return recommendations;
}

/**
 * Êé®ÈÄÅÂÆ°Êü•ËØÑËÆ∫Âà∞GitLab
 */
async function pushReviewCommentsToGitLab(
  gitlabClient: GitLabClient,
  projectId: string | number,
  mergeRequestIid: number,
  reviewResults: AICodeReviewResult[],
  reviewReport?: CodeReviewReport | null,
  commentStyle: string = "detailed"
): Promise<any> {
  try {
    console.log('üöÄ ÂºÄÂßãÊé®ÈÄÅÂÆ°Êü•ËØÑËÆ∫Âà∞GitLab...');
    
    const comments = [];
    
    // 1. Ê∑ªÂä†ÊÄª‰ΩìÂÆ°Êü•Êä•ÂëäËØÑËÆ∫
    if (reviewReport) {
      const summaryComment = generateSummaryComment(reviewReport, commentStyle);
      try {
        const summaryResult = await gitlabClient.addMergeRequestNote(projectId, mergeRequestIid, summaryComment);
        comments.push({ type: 'summary', id: summaryResult.id });
        console.log('‚úÖ ÊÄª‰ΩìÊä•ÂëäËØÑËÆ∫Â∑≤Ê∑ªÂä†');
      } catch (error) {
        console.warn('‚ö†Ô∏è  Ê∑ªÂä†ÊÄª‰ΩìÊä•ÂëäËØÑËÆ∫Â§±Ë¥•:', error);
      }
    }
    
    // 2. ‰∏∫ÈáçË¶ÅÈóÆÈ¢òÊ∑ªÂä†ÂçïÁã¨ËØÑËÆ∫
    let issueCommentCount = 0;
    for (const result of reviewResults) {
      const criticalIssues = result.issues.filter(issue => issue.severity === 'critical');
      const warningIssues = result.issues.filter(issue => issue.severity === 'warning');
      
      // Âè™‰∏∫criticalÂíåwarningÈóÆÈ¢òÊ∑ªÂä†Áã¨Á´ãËØÑËÆ∫ÔºàÈÅøÂÖçÂ§™Â§öspamÔºâ
      const importantIssues = [...criticalIssues, ...warningIssues.slice(0, 2)]; // ÊúÄÂ§ö2‰∏™warning
      
      for (const issue of importantIssues) {
        const issueComment = generateIssueComment(issue, result.file_path);
        try {
          const commentResult = await gitlabClient.addMergeRequestNote(projectId, mergeRequestIid, issueComment);
          comments.push({ 
            type: 'issue', 
            file: result.file_path, 
            severity: issue.severity,
            id: commentResult.id 
          });
          issueCommentCount++;
        } catch (error) {
          console.warn(`‚ö†Ô∏è  Êó†Ê≥ïÊ∑ªÂä†ÈóÆÈ¢òËØÑËÆ∫ ${result.file_path}:`, error);
        }
      }
    }
    
    console.log(`‚úÖ ÊàêÂäüÊé®ÈÄÅ ${comments.length} Êù°ÂÆ°Êü•ËØÑËÆ∫ (ÂåÖÂê´ ${issueCommentCount} ‰∏™ÈóÆÈ¢òËØÑËÆ∫)`);
    
    return {
      success: true,
      comments_added: comments.length,
      issue_comments: issueCommentCount,
      comments_details: comments,
      message: `Â∑≤ÊàêÂäüÂ∞ÜAI‰ª£Á†ÅÂÆ°Êü•ÁªìÊûúÊé®ÈÄÅÂà∞MR #${mergeRequestIid}`
    };
    
  } catch (error) {
    console.error('‚ùå Êé®ÈÄÅËØÑËÆ∫Â§±Ë¥•:', error);
    throw new Error(`Êé®ÈÄÅËØÑËÆ∫Â§±Ë¥•: ${error instanceof Error ? error.message : String(error)}`);
  }
}

/**
 * ÁîüÊàêÊÄª‰ΩìËØÑËÆ∫
 */
function generateSummaryComment(reviewReport: CodeReviewReport, style: string): string {
  const { summary, recommendations } = reviewReport;
  
  if (style === "minimal") {
    return `## ü§ñ AI‰ª£Á†ÅÂÆ°Êü•ÁªìÊûú
    
**ÊÄª‰ΩìËØÑÂàÜ**: ${summary.average_score}/100 | **Áä∂ÊÄÅ**: ${getStatusEmoji(summary.overall_status)} ${summary.overall_status}

${summary.critical_issues > 0 ? `üö® ${summary.critical_issues} ‰∏™‰∏•ÈáçÈóÆÈ¢ò` : ''}
${summary.warnings > 0 ? `‚ö†Ô∏è ${summary.warnings} ‰∏™Ë≠¶Âëä` : ''}
${summary.suggestions > 0 ? `üí° ${summary.suggestions} ‰∏™Âª∫ËÆÆ` : ''}`;
  }
  
  if (style === "summary") {
    return `## ü§ñ AI‰ª£Á†ÅÂÆ°Êü•Êä•Âëä

### üìä ÂÆ°Êü•Ê¶ÇÂÜµ
- **Êñá‰ª∂Êï∞Èáè**: ${summary.files_reviewed}‰∏™
- **ÊÄª‰ΩìËØÑÂàÜ**: ${summary.average_score}/100
- **ÂÆ°Êü•Áä∂ÊÄÅ**: ${getStatusEmoji(summary.overall_status)} ${summary.overall_status}

### üîç ÈóÆÈ¢òÁªüËÆ°
- üö® ‰∏•ÈáçÈóÆÈ¢ò: ${summary.critical_issues}‰∏™
- ‚ö†Ô∏è Ë≠¶Âëä: ${summary.warnings}‰∏™  
- üí° Âª∫ËÆÆ: ${summary.suggestions}‰∏™

${recommendations.length > 0 ? `\n### üìã ÊÄª‰ΩìÂª∫ËÆÆ\n${recommendations.map((rec: string) => `- ${rec}`).join('\n')}` : ''}`;
  }
  
  // detailed style
  return `## ü§ñ AI‰ª£Á†ÅÂÆ°Êü•ËØ¶ÁªÜÊä•Âëä

### üìä ÂÆ°Êü•Ê¶ÇÂÜµ
- **ÂÆ°Êü•Êñá‰ª∂**: ${summary.files_reviewed} ‰∏™
- **ÊÄª‰ΩìËØÑÂàÜ**: ${summary.average_score}/100 ‚≠ê
- **ÂÆ°Êü•Áä∂ÊÄÅ**: ${getStatusEmoji(summary.overall_status)} **${summary.overall_status}**

### üîç ÈóÆÈ¢òÂàÜÊûê
| Á±ªÂûã | Êï∞Èáè | ËØ¥Êòé |
|------|------|------|
| üö® ‰∏•ÈáçÈóÆÈ¢ò | ${summary.critical_issues} | ÂøÖÈ°ªÂú®ÂêàÂπ∂Ââç‰øÆÂ§ç |
| ‚ö†Ô∏è Ë≠¶Âëä | ${summary.warnings} | Âª∫ËÆÆÂ∞ΩÂø´Â§ÑÁêÜ |
| üí° Âª∫ËÆÆ | ${summary.suggestions} | ‰ºòÂåñÂª∫ËÆÆ |

### üìã ÂÆ°Êü•Âª∫ËÆÆ
${recommendations.map((rec: string) => `- ${rec}`).join('\n')}

### üïí ÂÆ°Êü•‰ø°ÊÅØ
- **ÂÆ°Êü•Êó∂Èó¥**: ${new Date().toLocaleString('zh-CN')}
- **ÂÆ°Êü•Â∑•ÂÖ∑**: AI Code Reviewer v1.0
- **MR‰ø°ÊÅØ**: ${reviewReport.review_metadata.mr_info.title}

---
> ËøôÊòØAIËá™Âä®ÁîüÊàêÁöÑ‰ª£Á†ÅÂÆ°Êü•Êä•Âëä„ÄÇÂ¶ÇÊúâÁñëÈóÆÔºåËØ∑ËÅîÁ≥ªÂºÄÂèëÂõ¢Èòü„ÄÇ`;
}

/**
 * ÁîüÊàêÈóÆÈ¢òËØÑËÆ∫
 */
function generateIssueComment(issue: CodeReviewIssue, filePath: string): string {
  const severityEmoji = {
    'critical': 'üö®',
    'warning': '‚ö†Ô∏è',
    'suggestion': 'üí°'
  };
  
  return `### ${severityEmoji[issue.severity]} ${issue.title}

**üìÅ Êñá‰ª∂**: \`${filePath}\`${issue.line_number ? ` (Á¨¨${issue.line_number}Ë°å)` : ''}

**üìù ÈóÆÈ¢òÊèèËø∞**: ${issue.description}

**üí° ‰øÆÊîπÂª∫ËÆÆ**: ${issue.suggestion}

${issue.auto_fixable ? 'üîß *Ê≠§ÈóÆÈ¢òÊîØÊåÅËá™Âä®‰øÆÂ§ç*' : ''}

---
*ÂàÜÁ±ª: ${issue.category} | ËßÑÂàôÊù•Ê∫ê: ${issue.rule_source}*`;
}

/**
 * Ëé∑ÂèñÁä∂ÊÄÅË°®ÊÉÖÁ¨¶Âè∑
 */
function getStatusEmoji(status: string): string {
  switch (status) {
    case 'PASS': return '‚úÖ';
    case 'WARNING': return '‚ö†Ô∏è';
    case 'CRITICAL': return 'üö®';
    default: return '‚ùì';
  }
} 